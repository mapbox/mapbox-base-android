This document outlines the build system modularization vision, architecture, and implementation details for Mapbox SDKs for Android.

## Why
We are introducing build system modularization to enable customization of Mapbox SDKs with minimal binary size overhead and to increase the overall separation of responsibilities across SDKs. The goal is to enable swapping SDK modules during compilation instead of exposing runtime configuration options and relying on third-party tools to remove unused code.

We streamline independent units of code as much as possible into SDK modules, described by transparent contracts (interfaces). For example, Mapbox SDKs typically have a networking module where the default implementation is OkHttp. The developer can replace the default implementation with a custom implementation without resulting in the SDK bundling unnecessary code, i.e., code for the default implementation is removed.

## How
_Disclaimer: all code examples in this doc are only examples. The actual names and implementation details of modules may differ._

The solution is built with 4 pieces:
- Module contracts
- Module implementations
- Module annotations
- Module provider

### Module contracts
Each module is described by a contract (interface) and a [`MapboxModuleType`](https://github.com/mapbox/mapbox-base-android/blob/master/annotations/src/main/java/com/mapbox/annotation/module/MapboxModuleType.kt) that points to this contract. The SDK will communicate with the implementation solely via this interface, leveraging the provided abstraction.

All SDK-specific contracts currently live in the respective Maps and Navigation SDK repositories (released separately from the SDK), unless there's a module that can be reused across both projects, like `LibraryLoader` found in [this repository's common project](https://github.com/mapbox/mapbox-base-android/tree/master/common/src/main/java/com/mapbox/common).

For the network stack example, the SDK's only requirement is to schedule the request, wait for the callback, and cancel the request if necessary. We can describe that with the contract below:

```
interface HttpClient {

  /**
   * Executes the request.
   */
  fun executeRequest(id: Long, resourceUrl: String, callback: HttpRequestCallback)

  /**
   * Cancels the request.
   */
  fun cancelRequest(id: Long)

  /**
   * Interface definition for delivering http request result.
   */
  interface HttpRequestCallback {

    /**
     * Delivers successful response's data.
     */
    fun onSuccess(data: ByteArray)

    /**
     * Delivers failure reason.
     */
    fun onFailure(reason: String)
  }
}
```

This contract will be shipped in an independent artifact that bundles several such contracts. During compilation, a Mapbox SDK solely depends on this artifact and the included contracts. The implementation details are added thereafter as a runtime dependency.

### Module implementations
Implementing a module means providing the details and logic of how the contract should be executed:
```
class HttpClientImpl(private val okHttpClient: OkHttpClient) : HttpClient, HttpClient.HttpRequestCallback {

  override fun executeRequest(id: Long, resourceUrl: String, callback: HttpClient.HttpRequestCallback) {
    val request = okhttp3.Request.Builder().url(resourceUrl).build()
    val call = okHttpClient.newCall(request).apply {
      enqueue(this@HttpClientImpl)
    }
    requests.add(Request(id, call, callback))
  }

  override fun cancelRequest(id: Long) {
    ...
  }

  override fun onFailure(call: Call, e: IOException) {
    ...
    httpRequestCallback.onFailure("")
  }

  override fun onResponse(call: Call, response: Response) {
    ...
    httpRequestCallback.onSuccess(byteArrayOf())
  }
}
```
This class can live anywhere in the project or dependency tree, but it has to be publicly available.

### Module annotations
To limit erroneous runtime configurations and simplify the configuration, itâ€™s required to annotate a module implementation with the appropriate annotation from the `com.mapbox.base:annotations` artifact found in [this package](https://github.com/mapbox/mapbox-base-android/tree/master/annotations/src/main/java/com/mapbox/annotation):
```
@MapboxModule(MapboxModuleType.HttpClient)
class HttpClientImpl(private val okHttpClient: OkHttpClient) : HttpClient, Callback {
  ...
}
```
This project also ships an [annotations processor](https://github.com/mapbox/mapbox-base-android/tree/master/annotations-processor) which consumes module annotations and generates the glue classes in constant packages.

### Module provider
The [`MapboxModuleProvider`](https://github.com/mapbox/mapbox-base-android/blob/master/common/src/main/java/com/mapbox/common/module/provider/MapboxModuleProvider.kt) takes the glue classes generated by the annotations processor and acquires or creates instances of the concrete module implementations using reflection. The glue classes are generated by the Mapbox-owned processor and the module provider uses the same public constants for package/method names, making this reflection safe.

The module provider always takes as parameters the module type (referenced from the implementation class annotation). It also takes a list of arguments required to instantiate/acquire the default, Mapbox provided module implementation, but this is designed for internal usage only.

For the network stack example, since the default `HttpClientImpl` requires an `OkHttpClient` instance, from a high-level perspective the SDK needs to invoke:
```
ModuleProvider.getModule(MapboxModuleType.HttpClient, OkHttpClient::class.java to myOkHttpClientInstance)
```

#### Dependency injection
To make both Mapbox default module implementations and custom ones testable, and allow for singleton instances that could be reused across multiple Mapbox SDKs, the annotation processor offers 2 variants of the generated glue class. The variants are distinguished by the `enableConfiguration` flag passed through the module annotation argument, next to the module type:
```
@MapboxModule(MapboxModuleType.HttpClient, enableConfiguration = true/false)
```
When `enableConfiguration = false`, the processor will not generate the configuration option in the resulting glue class. This results in the module provider trying to:

1. instantiate the module by the public, no-arg constructor
2. obtain the Kotlin `object` reference of the module implementation **(make sure to prevent minification/obfuscation of the `object.INSTANCE` field)**
3. call a static, Java `getInstance` method **(make sure to prevent minification/obfuscation of the `getInstance` method)**
4. call the constructor that accepts a list of default parameters, for Mapbox default modules internal usage only **(Mapbox SDK needs to make sure to prevent minification/obfuscation of the desired constructor)**.

```
@Keep
object Mapbox_HttpClientModuleConfiguration {
  @JvmStatic
  val enableConfiguration: Boolean = false

  @JvmStatic
  val implClass: Class<HttpClientImpl> = HttpClientImpl::class.java
}
```

The `enableConfiguration = false` flag state should be used in 2 scenarios:
- For all Mapbox default modules. This is done to hide the configuration option for default classes that Mapbox ships and to avoid for accidental overrides. When initializing the module, the SDK will try to pass hardcoded arguments that the default module expects. Those arguments are provided by each Mapbox SDK respectively.
- For developers overriding the default module who want their custom implementation to be instantiated by the Mapbox SDK using one of the methods listed above.

By default, configuration is disabled, `enableConfiguration = false`. A developer can enable configuration by passing`enableConfiguration = true` and the proccessor will generate a glue class that accepts a `ModuleProvider` interface. The `MapboxModuleProvider` will invoke this interface to acquire the module's reference.

```
@Keep
object Mapbox_HttpClientModuleConfiguration {
  @JvmStatic
  val enableConfiguration: Boolean = true

  /**
   * Set this dependency provider before initializing any components of the modularized library.
   *
   * When you're not using the library anymore, you should pass `null` to clean up the provider
   * reference and prevent memory leaks.
   */
  @JvmStatic
  var moduleProvider: ModuleProvider? = null

  interface ModuleProvider {
    fun createHttpClient(): HttpClient
  }
}
```
This unlocks dependency injection pattern and offers fine-grained control over custom module instances.

The configuration from a developer's perspective looks like the following:
```
override fun onCreate(savedInstanceState: Bundle?) {
  super.onCreate(savedInstanceState)

  Mapbox_HttpClientModuleConfiguration.moduleProvider =
    object : Mapbox_HttpClientModuleConfiguration.ModuleProvider {
      override fun createHttpClient(): HttpClient = HttpClientImpl(myOkHttpClient)
    }

  setContentView(R.layout.activity_simple_map)
  mapView = findViewById(R.id.mapView)
  mapboxMap = mapView.getMapboxMap()
  ...
```


### Usage

Modules are critical for the SDK to function properly, therefore each Mapbox SDK always bundles all of the default implementations with the main artifact as runtime dependencies. A developer can not only swap each module's implementation for a custom one, but also avoid binary size increases that would normally go with it, thanks to the modular architecture outlined above.

A Mapbox SDK will internally declare dependencies on base and default implementations:
```
implementation("com.mapbox.base:android-annotations:0.1.0")
implementation("com.mapbox.base:common:0.1.0")
runtimeOnly("com.mapbox.module-http-client:0.1.0")
```
which will allow it to use the functionality, regardless of the runtime implementation details:
```
val httpClient: HttpClient = MapboxModuleProvider.createModule(MapboxModuleType.CommonHttpClient, ::defaultParamsProvider)
httpClient.executeRequest(id, resourceUrl, callback)
```

Using the network stack as an example, a developer would do the following to provide a custom implementation and remove the default Mapbox implementation:
- Create the `CustomHttpClientImpl` class that overrides `HttpClient`
- Annotate that class with `@MapboxModule(MapboxModuleType.HttpClient, enableConfiguration = true/false)`
- If necessary, insert the instance provider using the generated `Mapbox_HttpClientModuleConfiguration.moduleProvider` field
- Adjust the build file to exclude the undesired default implementation and kickstart the generation:
```
compileOnly("com.mapbox.base:android-annotations:0.1.0")
kapt("com.mapbox.base:android-annotations-processsor:0.1.0")

implementation("com.mapbox.sdk:android:1.0.0") {
    exclude group: "com.mapbox.sdk", module: "module-http-client"
}
```

## FAQ:

#### Why do we need to use reflection to instantiate modules? Couldn't we always generate the right methods upfront and call then directly?
Unfortunately, this is not possible due to the order of compilation. Let's take 3 components as an example: a default module implementation, an SDK, and an app.

When building from source, the compilation process will run through the dependency tree from top to bottom: first compiling the module, then the SDK, and finally the app. If we exclude the default module and try to provide the custom one in the app project, then the SDK would not compile.

When consuming the pre-built binary instead of building from source, it would be possible for the SDK to hardcode the glue classes' paths to avoid triggering the reflection overhead. We are evaluating further whether this is a flavor that we can introduce.

#### Why are we not using kotlin-reflect?
We are using classic Java reflection to avoid binary size increase as a result of introducing additional dependencies. While using kotlin-reflect might improve performance, it also adds overhead. We will re-evaluate this trade-off decision in the future.
